---
source: src/output/sonarqube.rs
expression: parsed
---
{
  "issues": [
    {
      "effortMinutes": 5,
      "primaryLocation": {
        "filePath": "db/migrations/V042__add_index.sql",
        "message": "CREATE INDEX on existing table 'orders' should use CONCURRENTLY.",
        "textRange": {
          "endLine": 3,
          "startLine": 3
        }
      },
      "ruleId": "PGM001"
    }
  ],
  "rules": [
    {
      "cleanCodeAttribute": "COMPLETE",
      "description": "PGM001 — Missing CONCURRENTLY on CREATE INDEX\n\nWhat it detects:\nA CREATE INDEX statement that does not use the CONCURRENTLY option,\ntargeting a table that already exists in the database (i.e., the table\nwas not created in the same set of changed files).\n\nWhy it's dangerous:\nWithout CONCURRENTLY, PostgreSQL acquires an ACCESS EXCLUSIVE lock on\nthe table for the entire duration of the index build. This blocks ALL\nqueries — reads and writes — on the table. For large tables, index\ncreation can take minutes or hours, causing extended downtime.\n\nExample (bad):\nCREATE INDEX idx_orders_status ON orders (status);\n\nFix:\nCREATE INDEX CONCURRENTLY idx_orders_status ON orders (status);\n\nNote: CONCURRENTLY cannot run inside a transaction. If your migration\nframework wraps each file in a transaction (e.g., Liquibase default),\nyou must also disable that. See PGM006.\n\nThis rule does NOT fire when the table is created in the same set of\nchanged files, because locking an empty/new table is harmless.",
      "engineId": "pg-migration-lint",
      "id": "PGM001",
      "impacts": [
        {
          "severity": "HIGH",
          "softwareQuality": "RELIABILITY"
        }
      ],
      "name": "Missing CONCURRENTLY on CREATE INDEX",
      "severity": "CRITICAL",
      "type": "BUG"
    }
  ]
}
