//! Migration loading from different input formats
//!
//! Supports SQL files and Liquibase XML changesets.

use crate::parser::ir::{IrNode, Located};
use std::path::PathBuf;
use thiserror::Error;

pub mod liquibase_bridge;
pub mod liquibase_updatesql;
pub mod sql;

/// A single migration unit: one changeset (Liquibase) or one file (go-migrate).
#[derive(Debug, Clone)]
pub struct MigrationUnit {
    /// Identifier for ordering/logging. Changeset ID or filename.
    pub id: String,

    /// The SQL statements as IR nodes with source locations.
    pub statements: Vec<Located<IrNode>>,

    /// The source file to report findings against.
    pub source_file: PathBuf,

    /// Line offset in the source file where this unit starts.
    /// For raw SQL files this is 1. For Liquibase XML, it's the <changeSet> line.
    pub source_line_offset: usize,

    /// Whether this unit executes inside a transaction.
    /// Liquibase: derived from runInTransaction attribute.
    /// go-migrate: true by default unless explicitly disabled.
    pub run_in_transaction: bool,

    /// Is this a down/rollback migration?
    pub is_down: bool,
}

/// An ordered sequence of migration units representing the full history.
#[derive(Debug)]
pub struct MigrationHistory {
    pub units: Vec<MigrationUnit>,
}

/// Raw migration unit with unparsed SQL text. Used by Liquibase loaders
/// as an intermediate step before SQL parsing.
#[derive(Debug, Clone)]
pub struct RawMigrationUnit {
    /// Changeset identifier (e.g., "20240315-1").
    pub id: String,

    /// The raw SQL text extracted from or generated by the changeset.
    pub sql: String,

    /// The source file this unit came from.
    pub source_file: PathBuf,

    /// Line offset in the source file where this unit starts.
    pub source_line_offset: usize,

    /// Whether this unit executes inside a transaction.
    pub run_in_transaction: bool,

    /// Is this a down/rollback migration?
    pub is_down: bool,
}

impl RawMigrationUnit {
    /// Parse the raw SQL into IR and produce a `MigrationUnit`.
    ///
    /// Uses the pg_query parser to convert the SQL text into IR nodes.
    /// Adjusts statement line numbers by `source_line_offset` so that
    /// findings point to the correct line in the original file (e.g., the
    /// XML line for Liquibase changesets). For raw SQL files the offset
    /// is 1, making this a no-op.
    pub fn into_migration_unit(self) -> MigrationUnit {
        let mut statements = crate::parser::pg_query::parse_sql(&self.sql);

        // Shift line numbers so they are absolute within the source file.
        // The parser returns 1-based lines relative to the SQL snippet;
        // source_line_offset is the 1-based line where the snippet starts.
        if self.source_line_offset > 1 {
            let delta = self.source_line_offset - 1;
            for stmt in &mut statements {
                stmt.span.start_line += delta;
                stmt.span.end_line += delta;
            }
        }

        MigrationUnit {
            id: self.id,
            statements,
            source_file: self.source_file,
            source_line_offset: self.source_line_offset,
            run_in_transaction: self.run_in_transaction,
            is_down: self.is_down,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Helper: build a `RawMigrationUnit` with the given SQL and line offset.
    fn raw_unit(sql: &str, offset: usize) -> RawMigrationUnit {
        RawMigrationUnit {
            id: "test".to_string(),
            sql: sql.to_string(),
            source_file: PathBuf::from("test.sql"),
            source_line_offset: offset,
            run_in_transaction: true,
            is_down: false,
        }
    }

    /// With offset == 1 the parser's 1-based lines are already absolute,
    /// so no adjustment must happen.
    /// Kills the `>=` mutant (which would adjust at offset=1) and the `<`
    /// mutant (which would also adjust at offset=1).
    #[test]
    fn test_offset_one_no_adjustment() {
        let unit = raw_unit("CREATE TABLE t (id int);\n", 1).into_migration_unit();
        assert!(
            !unit.statements.is_empty(),
            "parser should produce at least one statement"
        );
        let span = &unit.statements[0].span;
        assert_eq!(
            span.start_line, 1,
            "start_line must stay 1 when offset is 1"
        );
        assert_eq!(span.end_line, 1, "end_line must stay 1 when offset is 1");
    }

    /// With offset > 1 (here 10), lines must shift by offset - 1 = 9.
    /// A statement originally on line 1 becomes line 10.
    /// Kills arithmetic mutants: `-` vs `+` in `offset - 1`,
    /// `+=` vs `-=`/`*=` in the delta application.
    #[test]
    fn test_offset_greater_than_one() {
        let unit = raw_unit("CREATE TABLE t (id int);\n", 10).into_migration_unit();
        assert!(!unit.statements.is_empty());
        let span = &unit.statements[0].span;
        // Parser returns line 1; delta = 10 - 1 = 9; result = 1 + 9 = 10
        assert_eq!(span.start_line, 10, "start_line should be shifted by 9");
        assert_eq!(span.end_line, 10, "end_line should be shifted by 9");
    }

    /// With offset == 2, delta = 1. A statement on line 1 becomes line 2.
    /// This kills the `==` mutant for `self.source_line_offset > 1`:
    /// if the condition were `== 1` it would NOT fire for offset=2,
    /// leaving lines unadjusted.
    #[test]
    fn test_offset_two_boundary() {
        let unit = raw_unit("CREATE TABLE t (id int);\n", 2).into_migration_unit();
        assert!(!unit.statements.is_empty());
        let span = &unit.statements[0].span;
        assert_eq!(span.start_line, 2, "start_line should be shifted by 1");
        assert_eq!(span.end_line, 2, "end_line should be shifted by 1");
    }

    /// With offset == 0, the condition `> 1` is false, so no adjustment.
    /// This confirms the guard works for offset < 1 as well.
    #[test]
    fn test_offset_zero_no_adjustment() {
        let unit = raw_unit("CREATE TABLE t (id int);\n", 0).into_migration_unit();
        assert!(!unit.statements.is_empty());
        let span = &unit.statements[0].span;
        assert_eq!(
            span.start_line, 1,
            "start_line must stay 1 when offset is 0"
        );
        assert_eq!(span.end_line, 1, "end_line must stay 1 when offset is 0");
    }

    /// Multi-line SQL: verify both start_line and end_line are adjusted
    /// independently. A CREATE TABLE spanning lines 1-3 with offset=5
    /// should become lines 5-7.
    #[test]
    fn test_offset_multiline_statement() {
        let sql = "CREATE TABLE t (\n  id int,\n  name text\n);\n";
        let unit = raw_unit(sql, 5).into_migration_unit();
        assert!(!unit.statements.is_empty());
        let span = &unit.statements[0].span;
        // The CREATE TABLE spans lines 1..=4 in the snippet (4 lines),
        // but pg_query may report different end_line. Regardless:
        // start_line should be original + 4, end_line should be original + 4.
        let delta: usize = 4; // 5 - 1
        assert!(
            span.start_line > 1,
            "start_line should have been shifted from 1"
        );
        assert_eq!(
            span.start_line,
            1 + delta,
            "start_line should be shifted by delta={delta}"
        );
        // end_line must also be shifted by the same delta
        assert!(span.end_line >= span.start_line, "end_line >= start_line");
        // The statement spans multiple lines, so end_line > start_line
        // after the shift. We verify the delta was applied correctly:
        // If original end_line was E, shifted should be E + delta.
        // Parse the same SQL with offset=1 to get the original end_line.
        let baseline = raw_unit(sql, 1).into_migration_unit();
        let original_end = baseline.statements[0].span.end_line;
        assert_eq!(
            span.end_line,
            original_end + delta,
            "end_line should be shifted by the same delta as start_line"
        );
    }

    /// Verify that metadata fields are passed through correctly.
    #[test]
    fn test_metadata_passthrough() {
        let raw = RawMigrationUnit {
            id: "cs-42".to_string(),
            sql: "SELECT 1;".to_string(),
            source_file: PathBuf::from("db/changelog.xml"),
            source_line_offset: 7,
            run_in_transaction: false,
            is_down: true,
        };
        let unit = raw.into_migration_unit();
        assert_eq!(unit.id, "cs-42");
        assert_eq!(unit.source_file, PathBuf::from("db/changelog.xml"));
        assert_eq!(unit.source_line_offset, 7);
        assert!(!unit.run_in_transaction);
        assert!(unit.is_down);
    }
}

#[derive(Debug, Error)]
pub enum LoadError {
    #[error("IO error reading {path}: {source}")]
    Io {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("Parse error in {path}: {message}")]
    Parse { path: PathBuf, message: String },

    #[error("Liquibase bridge failed: {message}")]
    BridgeError { message: String },

    #[error("Configuration error: {message}")]
    Config { message: String },
}
