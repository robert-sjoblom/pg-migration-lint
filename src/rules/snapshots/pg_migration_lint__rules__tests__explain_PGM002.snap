---
source: src/rules/mod.rs
expression: output
---
Rule: PGM002
Severity: CRITICAL
Description: Missing CONCURRENTLY on DROP INDEX

PGM002 — Missing CONCURRENTLY on DROP INDEX

What it detects:
A DROP INDEX statement that does not use the CONCURRENTLY option,
where the index belongs to a table that already exists in the database.

Why it's dangerous:
Without CONCURRENTLY, PostgreSQL acquires an ACCESS EXCLUSIVE lock on
the table associated with the index for the duration of the drop
operation. This blocks ALL queries — reads and writes — on the table.
While DROP INDEX is usually fast, it still briefly blocks concurrent
access and can queue behind long-running queries, amplifying the impact.

Example (bad):
DROP INDEX idx_orders_status;

Fix:
DROP INDEX CONCURRENTLY idx_orders_status;

Note: CONCURRENTLY cannot run inside a transaction. If your migration
framework wraps each file in a transaction, you must disable that.
See PGM003.

Partitioned tables:
PostgreSQL does NOT support DROP INDEX CONCURRENTLY on partitioned
parent indexes. Dropping a partitioned parent index acquires locks on
all partitions. However, dropping an ON ONLY index (before child
indexes are attached) is safe — it only affects the invalid parent stub.

Safe pattern for partitioned indexes:
1. CREATE INDEX ON ONLY parent_table (col);     -- parent stub
2. CREATE INDEX CONCURRENTLY ON child (col);    -- per-child
3. ALTER INDEX idx_parent ATTACH PARTITION idx_child;
-- To remove: reverse the process before dropping the parent.
