//! PGM105 — Don't use `serial` / `bigserial`
//!
//! Detects columns declared as `serial`, `bigserial`, or `smallserial`.
//! Identity columns (`GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY`) are
//! the SQL standard approach with better ownership semantics.

use crate::parser::ir::{AlterTableAction, IrNode, Located};
use crate::rules::{Finding, LintContext, Rule, Severity};

/// Rule that flags the use of `serial` / `bigserial` / `smallserial` column types.
pub struct Pgm105;

impl Rule for Pgm105 {
    fn id(&self) -> &'static str {
        "PGM105"
    }

    fn default_severity(&self) -> Severity {
        Severity::Info
    }

    fn description(&self) -> &'static str {
        "Column uses serial/bigserial instead of identity column"
    }

    fn explain(&self) -> &'static str {
        "PGM105 — Don't use `serial` / `bigserial`\n\
         \n\
         What it detects:\n\
         A column declared as `serial`, `bigserial`, or `smallserial`.\n\
         \n\
         Why it's worth noting:\n\
         The `serial` pseudo-types create an implicit sequence and set a\n\
         `nextval()` default, but the sequence is owned by the column in a\n\
         somewhat loose way. Dropping the column doesn't always drop the\n\
         sequence, permissions aren't inherited, and `pg_dump` may not\n\
         restore the relationship correctly in all edge cases.\n\
         \n\
         Since PostgreSQL 10, identity columns (`GENERATED ALWAYS AS IDENTITY`\n\
         or `GENERATED BY DEFAULT AS IDENTITY`) provide the same\n\
         auto-incrementing behavior with tighter ownership, better\n\
         permission handling, and compliance with the SQL standard.\n\
         \n\
         Example (flagged):\n\
           CREATE TABLE orders (id serial PRIMARY KEY);\n\
         \n\
         Fix:\n\
           CREATE TABLE orders (\n\
             id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY\n\
           );"
    }

    fn check(&self, statements: &[Located<IrNode>], ctx: &LintContext<'_>) -> Vec<Finding> {
        let mut findings = Vec::new();

        for stmt in statements {
            match &stmt.node {
                IrNode::CreateTable(ct) => {
                    for col in &ct.columns {
                        if col.is_serial {
                            findings.push(Finding::new(
                                self.id(),
                                self.default_severity(),
                                format!(
                                    "Column '{}' on '{}' uses a sequence default \
                                     (serial/bigserial). Prefer GENERATED {{ ALWAYS | BY DEFAULT }} \
                                     AS IDENTITY for new tables (PostgreSQL 10+). Identity columns \
                                     have better ownership semantics and are the SQL standard \
                                     approach.",
                                    col.name, ct.name,
                                ),
                                ctx.file,
                                &stmt.span,
                            ));
                        }
                    }
                }
                IrNode::AlterTable(at) => {
                    for action in &at.actions {
                        if let AlterTableAction::AddColumn(col) = action
                            && col.is_serial
                        {
                            findings.push(Finding::new(
                                    self.id(),
                                    self.default_severity(),
                                    format!(
                                        "Column '{}' on '{}' uses a sequence default \
                                         (serial/bigserial). Prefer GENERATED {{ ALWAYS | BY DEFAULT }} \
                                         AS IDENTITY for new tables (PostgreSQL 10+). Identity columns \
                                         have better ownership semantics and are the SQL standard \
                                         approach.",
                                        col.name, at.name,
                                    ),
                                    ctx.file,
                                    &stmt.span,
                                ));
                        }
                    }
                }
                _ => {}
            }
        }

        findings
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::catalog::Catalog;
    use crate::parser::ir::*;
    use crate::rules::test_helpers::{located, make_ctx};
    use std::collections::HashSet;
    use std::path::PathBuf;

    #[test]
    fn test_serial_fires() {
        let before = Catalog::new();
        let after = Catalog::new();
        let file = PathBuf::from("migrations/001.sql");
        let created = HashSet::new();
        let ctx = make_ctx(&before, &after, &file, &created);

        let stmts = vec![located(IrNode::CreateTable(CreateTable {
            name: QualifiedName::unqualified("orders"),
            columns: vec![ColumnDef {
                name: "id".to_string(),
                type_name: TypeName::simple("int4"),
                nullable: false,
                default_expr: Some(DefaultExpr::FunctionCall {
                    name: "nextval".to_string(),
                    args: vec![],
                }),
                is_inline_pk: true,
                is_serial: true,
            }],
            constraints: vec![],
            temporary: false,
        }))];

        let findings = Pgm105.check(&stmts, &ctx);
        assert_eq!(findings.len(), 1);
        assert_eq!(findings[0].rule_id, "PGM105");
        assert_eq!(findings[0].severity, Severity::Info);
        assert!(findings[0].message.contains("id"));
        assert!(findings[0].message.contains("serial/bigserial"));
    }

    #[test]
    fn test_bigserial_fires() {
        let before = Catalog::new();
        let after = Catalog::new();
        let file = PathBuf::from("migrations/001.sql");
        let created = HashSet::new();
        let ctx = make_ctx(&before, &after, &file, &created);

        let stmts = vec![located(IrNode::CreateTable(CreateTable {
            name: QualifiedName::unqualified("orders"),
            columns: vec![ColumnDef {
                name: "id".to_string(),
                type_name: TypeName::simple("int8"),
                nullable: false,
                default_expr: Some(DefaultExpr::FunctionCall {
                    name: "nextval".to_string(),
                    args: vec![],
                }),
                is_inline_pk: true,
                is_serial: true,
            }],
            constraints: vec![],
            temporary: false,
        }))];

        let findings = Pgm105.check(&stmts, &ctx);
        assert_eq!(findings.len(), 1);
        assert!(findings[0].message.contains("serial/bigserial"));
    }

    #[test]
    fn test_identity_no_finding() {
        let before = Catalog::new();
        let after = Catalog::new();
        let file = PathBuf::from("migrations/001.sql");
        let created = HashSet::new();
        let ctx = make_ctx(&before, &after, &file, &created);

        // An int4 column without the is_serial flag — e.g. GENERATED ALWAYS AS IDENTITY
        let stmts = vec![located(IrNode::CreateTable(CreateTable {
            name: QualifiedName::unqualified("orders"),
            columns: vec![ColumnDef {
                name: "id".to_string(),
                type_name: TypeName::simple("int4"),
                nullable: false,
                default_expr: None,
                is_inline_pk: true,
                is_serial: false,
            }],
            constraints: vec![],
            temporary: false,
        }))];

        let findings = Pgm105.check(&stmts, &ctx);
        assert!(findings.is_empty());
    }

    #[test]
    fn test_add_column_serial_fires() {
        let before = Catalog::new();
        let after = Catalog::new();
        let file = PathBuf::from("migrations/002.sql");
        let created = HashSet::new();
        let ctx = make_ctx(&before, &after, &file, &created);

        let stmts = vec![located(IrNode::AlterTable(AlterTable {
            name: QualifiedName::unqualified("orders"),
            actions: vec![AlterTableAction::AddColumn(ColumnDef {
                name: "seq_id".to_string(),
                type_name: TypeName::simple("int4"),
                nullable: true,
                default_expr: Some(DefaultExpr::FunctionCall {
                    name: "nextval".to_string(),
                    args: vec![],
                }),
                is_inline_pk: false,
                is_serial: true,
            })],
        }))];

        let findings = Pgm105.check(&stmts, &ctx);
        assert_eq!(findings.len(), 1);
        assert!(findings[0].message.contains("seq_id"));
    }
}
